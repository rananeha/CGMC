//This script is run as ./mcs -I 1LFH_biopython_5.angs -D 1LFH.coords.2 -E 1LFH_axes4.out -X /home/nrana/Desktop/Software/CGMC -O RESULT
//








#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <fstream>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include "cgleaf.H"
#include "cgchain.H"
#include "cgslist.H"
#include "cgpairtree.H"
#include "cgligand.H"
#include "cgcrmsd.H"
#include "cgnode.H"

#define PROB_QUADB_FILE "computed_probability_specific_quadruplets_buried.txt"
#define PROB_QUADE_FILE "computed_probability_specific_quadruplets_exposed.txt"
#define PROB_QUADI_FILE "computed_probability_specific_quadruplets_intermediate.txt"
#define PROB_TRIPB_FILE "computed_probability_specific_triplets_buried.txt"
#define PROB_TRIPE_FILE "computed_probability_specific_triplets_exposed.txt"
#define PROB_TRIPI_FILE "computed_probability_specific_triplets_intermediate.txt"
#define PROB_SING_FILE "computed_probability_specific_singlets.txt"

#define LIG_QUADB_FILE "ligand_probability_specific_quadruplets_buried.txt"
#define LIG_QUADE_FILE "ligand_probability_specific_quadruplets_exposed.txt"
#define LIG_QUADI_FILE "ligand_probability_specific_quadruplets_intermediate.txt"
#define LIG_TRIPB_FILE "ligand_probability_specific_triplets_buried.txt"
#define LIG_TRIPE_FILE "ligand_probability_specific_triplets_exposed.txt"
#define LIG_TRIPI_FILE "ligand_probability_specific_triplets_intermediate.txt"
#define LIG_SING_FILE "ligand_probability_specific_singlets.txt"

using namespace std;
void generateTorsionMove(vector<ANGLE_CHANGE> & angles, int length, int num_moves, REAL std_angle);
void generateRotamerMove(vector<ANGLE_CHANGE> & angles, vector<ROTAMER_CHANGE> & rotamers, int length, int bbangs, int num_rot_changes, const CChain & chain);
void generateLigandMove(vector<LIGAND_CHANGE> & poses, int num_poses, int numconf);
bool acceptMove(REAL prev, REAL curr);
float normRand();
REAL attemptMCMove(const vector<ANGLE_CHANGE> & angles,const vector<ROTAMER_CHANGE> & rotamers,const vector<LIGAND_CHANGE> & poses,CSkiplist & sl, REAL energy, bool bBack, int num_angs, const char * nfile);
//REAL attemptMCLigand(MonteCarloLigand & mcl, int pose, int k, CSkiplist & sl, REAL energy, bool bBack, CChain & chain, vector<lpose *> accept_coords);
//REAL attemptMCLigand(MonteCarloLigand & mcl, int pose, int k, CSkiplist & sl, REAL energy, bool bBack, CChain & chain, double (*pxs)[3], double (*cxs)[3], vector<LPOSE> & accept_coords, const char * nfile);
REAL attemptMCLigand(MonteCarloLigand & mcl, int pose, int k, CSkiplist & sl, REAL energy, bool bBack, CChain & chain, vector<LPOSE> & accept_coords, const char * nfile);
void storeState(int step, REAL energy, ofstream & fout, CChain & chain);
/*******************************************************************************
Options:

-I file: The structure input file. The allowed formats is:
             AA name phi-angle psi-angle rotamer index
             The file must have a ".angs" extension.
-D file:     File of input coordinates
-E file:     File of axes based on input coordinates, generated by prepareAxisRotation.py
-L file:     File of ligand(s)
-M file:     Naccess file name
-P Center:   Center of translation window  
-B tunber:   Tunnel number
-H dir:      The directory where the executable resides.
-C rfile     Use this structure as a reference for all cRMSD computations
-T temp:     The temperature of the simulation in Kelvin.(default is 298)
-S steps:    The number of trial steps in the MCS. (default is 100,000)
-N interval: How often to store the current structure. Namely, the number of trial steps between save operations (default is 1000).
-K bbangs:   The number of backbone angles to change simultaneously (default is 1)
-F numrot    How many rotamer step to make per backbone step (default is 5)
-R rots:     The number of rotamers to change each time (default is 1) 
-G num_poses:How many poses of ligand to be generated
-J numconf:  Number of conformer of ligand used.
-O output:   The name of the output file prefix (including directory name). The default is to only save final results.
-U rseed:    The random seed to be used.
-A angle:    The std of each angular change.
-X tempdir   The directory where intermediate results will be saved.
*******************************************************************************/
char ifile[100] = "";
char dfile[100] = "";
char xfile[100] = "";
char rfile[100] = "";
char lfile[100] = "";
char nfile[100] = "";
REAL tunber;
REAL pointx, pointy, pointz;
REAL temper = T_0;
REAL temperature;
int numSteps = 100;
int interval = 10;
int bbangs = 1;
int numrot = 0; //NR
int rotangs = 5;
int num_poses = 1000;
int numconf;
char ofile[100] = "";
int ifType;
int rseed = 0;
bool noOutput = false;
REAL stdAngle = 10*M_PI/180.0;
bool crmsd;
bool refStruct = false;
char dir[100] = ".";
char tempdir[100] = "";
REAL angle_factor = 1.0;

POSITIONS pos0, posCurr;;

void parseCommandLine(int argc, char ** argv)
{
  int i = 1;
  while (i < argc)
  {
  if (strncmp(argv[i], "-I", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No input file name provided!" << endl;
	  exit(0);
	}

      strcpy(ifile, argv[++i]);
      cout << ifile << endl;      
    }
  else if (strncmp(argv[i], "-D", 2) == 0)
    {
      if (argc < i + 2)
        {
          cout << "No coordinate file name provided!" << endl;
          exit(0);
        }

      strcpy(dfile, argv[++i]);
      cout << dfile << endl;
    }
  else if (strncmp(argv[i], "-E", 2) == 0)
    {
      if (argc < i + 2)
        {
          cout << "No axes file name provided!" << endl;
          exit(0);
        }

      strcpy(xfile, argv[++i]);
      cout << xfile <<endl;
    }
  else if (strncmp(argv[i], "-X", 2) == 0)
    {
      if (argc < i + 2)
        {
          cout << "No temporary directory name provided!" << endl;
          exit(0);
        }

      strcpy(tempdir, argv[++i]);
      cout <<  tempdir << endl;
    }
  else if (strncmp(argv[i], "-L", 2) == 0)
    {
      if (argc < i + 2)
        {
          cout << "No ligand file name provided!" << endl;
          exit(0);
        }

      strcpy(lfile, argv[++i]);
      cout << lfile <<endl;
    }
  else if (strncmp(argv[i], "-M", 2) == 0)
    {
      if (argc < i + 2)
        {
          cout << "No ligand conformer file name provided!" << endl;
          exit(0);
        }

      strcpy(nfile, argv[++i]);
      cout << nfile <<endl;
    }
  else if (strncmp(argv[i], "-P", 2) == 0)
    {
      if (argc < i + 2)
        {
          cout << "No temporary directory name provided!" << endl;
          exit(0);
        }

      pointx = atof(argv[++i]);
      pointy = atof(argv[++i]);
      pointz = atof(argv[++i]);
      cout << pointx << "  " << pointy << "  " << pointz << endl;
    }
  else if (strncmp(argv[i], "-B", 2) == 0)
    {
      if (argc < i + 2)
        {
          cout << "No temporary directory name provided!" << endl;
          exit(0);
        }

      tunber = atof(argv[++i]);
      cout << tunber << endl;
    }
  else if (strncmp(argv[i], "-H", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No home directory was provided!" << endl;
	  exit(0);
	}

      strcpy(dir, argv[++i]);
      
    }
  else if (strncmp(argv[i], "-C", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "A pdb files need to be provided for -C option!" << endl;
	  exit(0);
	}

      refStruct = true;
      strcpy(rfile, argv[++i]);
    }
  else if (strncmp(argv[i], "-T", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No system temperature provided!" << endl;
	  exit(0);
	}
      temper = atof(argv[++i]);
    }
  else if (strncmp(argv[i], "-S", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No  number of trial steps provided!" << endl;
	  exit(0);
	}
      numSteps = atoi(argv[++i]);
    }

  else if (strncmp(argv[i], "-N", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No interval size provided!" << endl;
	  exit(0);
	}
      interval = atoi(argv[++i]);
    }
  else if (strncmp(argv[i], "-K", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No number of backbone angles to change per step provided!" << endl;
	  exit(0);
	}
      bbangs = atoi(argv[++i]);
    }
  else if (strncmp(argv[i], "-F", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "The number of rotamer moves to make per backbone move!" << endl;
	  exit(0);
	}
      numrot = atoi(argv[++i]);
    }
  else if (strncmp(argv[i], "-R", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No number of rotamers to change per rotamer step provided!" << endl;
	  exit(0);
	}
      rotangs = atoi(argv[++i]);
    }
  else if (strncmp(argv[i], "-G", 2) == 0)
    {
      if (argc < i + 2)
        {
          cout << "Number of ligand moves to change per backbone move!" << endl;
          exit(0);
        }
      num_poses = atoi(argv[++i]);
    }
  else if (strncmp(argv[i], "-J", 2) == 0)
    {
      if (argc < i + 2)
        {
          cout << "Number of ligand conformers supplied!" << endl;
          exit(0);
        }
      numconf = atoi(argv[++i]);
    }
  else if (strncmp(argv[i], "-O", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No output file prefix provided!" << endl;
	  exit(0);
	}
      strcpy(ofile, argv[++i]);
    }
  else if (strncmp(argv[i], "-U", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No random seed provided!" << endl;
	  exit(0);
	}
      rseed = atoi(argv[++i]);
    }
  else if (strncmp(argv[i], "-A", 2) == 0)
    {
      if (argc < i + 2)
	{
	  cout << "No std of backbone angular change provided!" << endl;
	  exit(0);
	}
      stdAngle = atof(argv[++i])*M_PI/180.0;
    }
  else
    {
      cout << "Bad command line input!!!" << endl;
      exit(0);
    }
  
  i++;
  }
}

void checkOptions()
{

  char * ext = strrchr(ifile, '.');
  if (!ext)
    {
      cout << "No input file extension! " << ifile << " " << endl;
      exit(0);
    }
      
  if (strcmp(".angs", ext) == 0)
    ifType = ANGS_FILE;
  else
    {
      cout << "Bad input file extension, wrong type of file!" << endl;
      exit(0);
    }

  if (refStruct)
    {
      char * ext1 = strrchr(rfile, '.');

      if (strcmp(".pdb", ext1) != 0)
	{
	  cout << "Input reference structure file needs to be a PDB file" << endl;
	  exit(0);
	}
    }

  if (rotangs == 0)
    numrot = 0;

  if (strcmp(ofile, "") == 0)
    noOutput = true; 

  temperature = 1.0/(Kb * temper);
}

void printOptions(ostream & out)
{
  out << "The input file is: " << ifile << endl;
  out << "The simulation will have " << numSteps << " trial steps" << endl;
  out << "Each step consists of a backbone move followed by " << numrot << " sidechain moves" << endl;
  out << "Each backbone move consists of changing " << bbangs << " backbone angles with a StDev of " << stdAngle*180.0/M_PI << endl;
  if (numrot > 0)
    out << "Each rotamer move consists of changing " << rotangs << " rotamers" << " selected at random." << endl;
  out << "The temperature of the simulation is " << temper << endl; 
  out << "Intermediate results will be saved every " << interval << " trial backbone steps" << endl;
  if (!noOutput)
    out << "Output will be written to " << ofile << " with suitable extensions" << endl;
  else
    out << "Only final output will be saved in the current directory" << endl;
  out << "The random seed is " << rseed << endl;
  if (refStruct)
    out << "The reference structure is: " << rfile << endl;
}

int main(int argc, char ** argv)
{ 
  parseCommandLine(argc, argv);
  checkOptions();

  printOptions(cout); 
  //exit(0);
  Initialize(dir);
  int size = LIGAND::m_liglist[0]->m_size;
  //for (int i = 0; i < size; i++)
     //cout << LIGAND::m_liglist[0]->m_lconformer[0]->m_positions[i][0] << endl;
  //exit(0);
  //Find COM of all rotamers, their probabilities wrt backbone phi and psi, their bv.
  //For finding bv, one needs all atoms position. So add two parameters to SIDECHAIN or ROTAMER classes: prob, COM
  //One does not need size (number of atoms), nGroups, nChis, charges, aTypes, chiTypes, aNames 
  cout <<  "Initialized" << endl;
  
  ofstream fout;
  srand48(rseed);
  
  // Open main output file
  char buf[100];
  sprintf(buf, "%s/%s_prot.out", dir, ofile);
  fout.open(buf);
      
  if (!fout.is_open())
    {
      cout << "Could not open output file " << buf << endl;
      exit(1);
    }
  

  //if (fout.bad())
  //{
    //cerr << "Unable to open output file\n";
    //exit(8);
  //}
  // Store the command lline options in a file.
  sprintf(buf, "%s/%s.opt", dir, ofile);
  ofstream fopt(buf);
  //ofstream fopt("%s/%s.opt", dir, ofile);
  printOptions(fopt);
  cout << "Parmeters written to file.\n" << endl;

  // Create the chain from the description in the file.
  char f[100];
  char fD[100];
  char fAX[100];
  char fn_quadB[100];
  char fn_quadE[100];
  char fn_quadI[100];
  char fn_tripB[100];
  char fn_tripE[100];
  char fn_tripI[100];
  char fn_sing[100];
  char fl_quadB[100];
  char fl_quadE[100];
  char fl_quadI[100];
  char fl_tripB[100];
  char fl_tripE[100];
  char fl_tripI[100];
  char fl_sing[100];

  sprintf(f, "%s/%s", dir, ifile);
  sprintf(fD, "%s/%s", dir, dfile);
  sprintf(fAX, "%s/%s", dir, xfile);
  sprintf(fn_quadB, "%s/%s", dir, PROB_QUADB_FILE);
  sprintf(fn_quadE, "%s/%s", dir, PROB_QUADE_FILE);
  sprintf(fn_quadI, "%s/%s", dir, PROB_QUADI_FILE);
  sprintf(fn_tripB, "%s/%s", dir, PROB_TRIPB_FILE);
  sprintf(fn_tripE, "%s/%s", dir, PROB_TRIPE_FILE);
  sprintf(fn_tripI, "%s/%s", dir, PROB_TRIPI_FILE);
  sprintf(fn_sing, "%s/%s", dir, PROB_SING_FILE);
  sprintf(fl_quadB, "%s/%s", dir, LIG_QUADB_FILE);
  sprintf(fl_quadE, "%s/%s", dir, LIG_QUADE_FILE);
  sprintf(fl_quadI, "%s/%s", dir, LIG_QUADI_FILE);
  sprintf(fl_tripB, "%s/%s", dir, LIG_TRIPB_FILE);
  sprintf(fl_tripE, "%s/%s", dir, LIG_TRIPE_FILE);
  sprintf(fl_tripI, "%s/%s", dir, LIG_TRIPI_FILE);
  sprintf(fl_sing, "%s/%s", dir, LIG_SING_FILE);

  //exit(0);
  //CChain chain(f, fAX, fD, ifType);
  CChain chain(f, fAX, fD, fn_quadB, fn_quadE, fn_quadI, fn_tripB, fn_tripE, fn_tripI, fn_sing, fl_quadB, fl_quadE, fl_quadI, fl_tripB, fl_tripE, fl_tripI, fl_sing, ifType);
  cout << "Chain loaded" << endl;
  
  // Store the initial conformations.
  char cc[100];
  if (!noOutput)
    {
      sprintf(cc, "%s/%s_%06d_original.pdb", tempdir, ofile, 0);
      cout << cc << endl;
      chain.store_orig_Coordinates(cc, fD);
    }
  cout << "Adjust chain" << endl;
  //exit(0);
  chain.adjustBV();
  cout << "chain adjusted" << endl;

  // Call Monte Carlo Ligand class
  MonteCarloLigand mcl(lfile, pointx, pointy, pointz);

  // create chaintree
  CSkiplist sl(chain);
  cout << "Hierarchy tree created" << endl;
  vector<ANGLE_CHANGE> angles(bbangs + 1);
  vector<ROTAMER_CHANGE> rotamers(rotangs + 1);
  vector<LIGAND_CHANGE> poses(num_poses + 1);

  vector<ANGLE_CHANGE> no_angle_change(1);
  no_angle_change[0].m_index = chain.getLength() + 1;
  vector<ROTAMER_CHANGE> no_rotamer_change(1);
  no_rotamer_change[0].m_index = chain.getLength() + 1;
  vector<LIGAND_CHANGE> no_pose_change(1);
  //no_pose_change[0].m_index = lig.numatoms + 1;
  no_pose_change[0].m_index = numconf + 1;

  cout << "calculate energy " << endl;
  int i;
  // Compute the initial energy of the structure
  //REAL energy = sl.computeEnergy(no_angle_change);
  REAL energy = sl.computeEnergy(nfile);
  cout << "The energy of the initial conformation is " << energy << endl; 
  cout << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
  
  // Store the initial conformations.
  //char cc[100];
  if (!noOutput)
    {
      sprintf(cc, "%s/%s_%06d.pdb", tempdir, ofile, 0);
      cout << cc << endl;
      //chain.store_orig_Coordinates(cc, fD);
      chain.storeCoordinates(cc);
      //lig.storeCoordinates(cc);
      //mcl.storeCoordinates(cc);
      sprintf(cc, "%s/%s_%06d.angs", tempdir, ofile, 0);
      chain.storeAngsStyle(cc);
    }
  exit(0);
  // Load the reference structure.
  if (refStruct)
    {
      sprintf(f, "%s/%s", dir, rfile);
      loadCas(f, pos0);
    }
  else
    // If none given use the initial structure as reference.
    chain.getCaPositions(pos0);

  int looper = 0;
  double (*txs)[3];
  double (*sxs)[3];
  vector<LPOSE> accept_coords(num_poses);
  // The main loop of the simulation.
  //**************************************************************
  for (i = 1; i <= numSteps; i++)
    {
      cout << "Step: " << i << endl;
      //cout << chain.getLength() << endl;
      //exit(0);
      // Perform the backbone move.
      generateTorsionMove(angles, chain.getLength(), bbangs, stdAngle);
      energy = attemptMCMove(angles, no_rotamer_change, no_pose_change, sl, energy, true,
			     bbangs, nfile);
      cout << "Torsion done " << endl; 
      // Perform all the rotamer moves 
      for (int j = 0; j < numrot; j++)
	{
	  generateRotamerMove(angles, rotamers, chain.getLength(), bbangs, rotangs, chain);
	  energy = attemptMCMove(no_angle_change, rotamers, no_pose_change, sl, energy,
				 false, -1, nfile);
	}
      cout << "Rotamer done " << endl;
      // Perform all ligand moves
      generateLigandMove(poses, num_poses, numconf);
      for (int k = 0; k < num_poses; k++)
         cout << poses[k].m_confIndex ;
      cout << "\nLigand done " << endl;
      for (int k = 0; k < num_poses; k++)
      {
         looper = k;
         //generateLigandMove(poses, num_poses, numconf);
         //energy = attemptMCLigand(mcl, poses[k].m_index, looper, sl, energy, false, chain, accept_coords);
         energy = attemptMCLigand(mcl, poses[k].m_confIndex, looper, sl, energy, false, chain, accept_coords, nfile);
         k = looper;
      }
      // Store the current state every 'interval' number of steps.
      //if (i % interval == 0)
      mcl.WriteLigCoordinates(accept_coords, num_poses, ofile);
      /*
      for (int k = 0; k < num_poses; k++)
      {
         REAL (*xs)[3] = accept_coords[k].pxs;
         mcl.WriteLigCoordinates(xs, fout);
         
      }*/
       	storeState(i, energy, fout, chain);
    }
  //********************************************************************
  
  if (noOutput)
    {
      chain.storeCoordinates("output.pdb");
      chain.storeAngsStyle("output.angs");
    }

  return 0;
}

REAL attemptMCMove(const vector<ANGLE_CHANGE> & angles,
		   const vector<ROTAMER_CHANGE> & rotamers,
		   const vector<LIGAND_CHANGE> & poses,
		   CSkiplist & sl, REAL energy, bool bBack, int num_angs, const char * nfile)
{
  //sl.makeMove(angles, rotamers, poses);
  sl.makeMove(angles, rotamers);
  REAL newEnergy;

  if (sl.findSelfClash())
    {
      sl.undoLastMove();
      cout << "Clash found\n" << endl;
      return energy;
    }
  else
    {
      cout << "New energy: " << newEnergy << endl;
      //exit(0);
      //newEnergy = sl.computeEnergy(angles);
      newEnergy = sl.computeEnergy(nfile);
      cout << newEnergy << endl;  
      if (!acceptMove(energy, newEnergy))
	{
	  sl.undoLastMove();
	  return energy;
	}
      else
	return newEnergy;
    }
}

//REAL attemptMCLigand(MonteCarloLigand & mcl, int pose, int k,
//		     CSkiplist & sl, REAL energy, bool bBack, CChain & chain, vector<lpose *> accept_coords) //Why need CSkiplist & sl? Should it be CChain & chain
//REAL attemptMCLigand(MonteCarloLigand & mcl, int pose, int k,
//		CSkiplist & sl, REAL energy, bool bBack, CChain & chain, double (*pxs)[3], double (*cxs)[3], vector<LPOSE> & accept_coords, const char * nfile)
REAL attemptMCLigand(MonteCarloLigand & mcl, int pose, int k,
		CSkiplist & sl, REAL energy, bool bBack, CChain & chain, vector<LPOSE> & accept_coords, const char * nfile)
{

  vector<CLeaf *> res_list;
  //vector<int > res_index;
  //vector<REAL *> pxs[3];
  //mcl.MC_Ligand(chain, pose, res_index, pxs, cxs);
  mcl.MC_Ligand(chain, pose);
  //cout << "MC_Ligand step done" << endl;
  //cout << mcl.get_pxs()[0][0] << " " << mcl.get_pxs()[0][1] << " " << mcl.get_pxs()[0][2] << endl;
  REAL newEnergy;
  CNode cnode(0);
  CLeaf * l_pLeaf = mcl.getLink(0); //mcl.getLigLeaf();
  //cout << l_pLeaf->getLeafSize() << endl;
  //CNode * curr = (CNode*) mcl.getLigLeaf(); //Is this right?
  CNode * curr = (CNode*) l_pLeaf;
  CLeaf * pLeaf = chain.getLink(0);

  int i = 0;
  //while (res_index[i])
  while (mcl.get_res_index()[i])
  {
     //pLeaf = chain.getLink(mcl.get_res_index()[i]);
     //cout << "res_index " << mcl.get_res_index()[i] << endl;
     //res_list.push_back(pLeaf);
     i += 1;
  }
  //cout << "Till here, everything's fine" << endl;
  accept_coords[k].save_pxs = mcl.get_pxs();
  accept_coords[k].save_cxs = mcl.get_cxs();
  //if (cnode.findClash(curr, res_list)) // Should it be curr->findClash(res_list) ?
  //if (CNode::findClash(curr, res_index))
  //cout << "Till here, everything's fine" << endl;
  if (cnode.findClash(curr, mcl.get_res_index(), chain))
    {
      k--;
      mcl.undoLastMove(accept_coords);
      //cout << "Ligand clash found\n" << endl;
      //return energy;
	  return NULL;
    }
  else
    {
      //cout << "New ligand energy: " << endl;
      //newEnergy = sl.computeLigEnergy(nfile);
      newEnergy = sl.computeLigEnergy(mcl.get_cxs(), nfile);
      //cout << newEnergy << endl;
      if (!acceptMove(energy, newEnergy))
        {
          k--;
          mcl.undoLastMove(accept_coords);
          return energy;
        }
      else
        {
          //cout << "k " << k << endl;
          return newEnergy;
        }
    }
   //cout << "Till Here, everything's fine" << endl;
}

// The acceptance rule for the MC simulation.
bool acceptMove(REAL prev, REAL curr)
{
  REAL diff = prev - curr;
  //cout << "diff: " << diff << endl;
  if (diff >= 0)
    return true;
  else if (diff*temperature < -15)
    return false;
  else
    {
      REAL e = exp(diff*temperature);
      REAL r = drand48();
      if (r < e)
	return true;
      else
	return false;
    }
}

// A random number generator that picks numbers from a normal distribution.
float normRand()
{
  static float saved;
  static bool bSaved = false;

  float v1, v2, rsq;
  if (!bSaved)
    {
      do {
	v1 = 2.0 * drand48() - 1.0;
	v2 = 2.0 * drand48() - 1.0;
	rsq = v1*v1 + v2*v2;
      } while (rsq >= 1.0 || rsq == 0.0);

      float fac = sqrt(-2.0*log(rsq)/rsq);
      saved = v1*fac;
      bSaved = true;
      return fac*v2;
    }
  else
    {
      bSaved = false;
      return saved;
    }
}

void generateTorsionMove(vector<ANGLE_CHANGE> & angles, int length, int num_moves, 
			 REAL std_angle)
{
  int k;
  int used[num_moves];

  // Generate torsion moves
  for (k = 0; k < num_moves; k++)
    {
      bool found = false;

      // The first phi angle and last psi angle are not changed.
      int index = lrand48() % (length - 3) + 1;
      if (index%3 == 0)
        {
           cout << "index" << endl;
           k--;
           continue;
        }
      for (int pp = 0; pp < k; pp++)
	{
        
          if (used[pp] == index)
	    {
              cout << "index" << endl;
	      found = true;
	      break;
	    }
	}
      if (found)
	{ 
	  k--;
	  continue;
	}

      used[k] = index;
      angles[k].m_index = index;
      angles[k].m_angle = normRand() * std_angle;
    }

  // Insert stopper.
  angles[k].m_index = length + 1;

  //sort(angles.begin(), angles.end(), ANGLE_CHANGE_COMP());
  for (int x = 0; x != angles.size(); ++x)
  {
    cout << angles[x].m_index << "   " << angles[k].m_angle << endl;
  }
}

void generateRotamerMove(vector<ANGLE_CHANGE> & angles, vector<ROTAMER_CHANGE> & rotamers, 
			 int length, int num_moves, int num_rot_changes, 
			 const CChain & chain)
{
  int k;
  int p1=0;
  // Generate rotamer moves.
   for (k = 0; k < num_moves; k++)
      {
       bool found = false;

       int index = angles[k].m_index;
       int n1 = SIDECHAIN::m_aalist[chain.getLink(index)->getType()]->m_nRotamers;

       int ri;
       if (n1 > 1)
       {
        ri = (lrand48() % (n1 - 1));
        rotamers[p1].m_index = index;
        rotamers[p1].m_rotIndex = ri;
        p1++;
       }
       else
       {
        continue;
       }
      }
   for (k = 0; k < num_rot_changes-num_moves; k++)
      {
       bool found = false;

       // Only odd numbered links contain side-chains
       int index = (lrand48() % ((length - 1)/2))*2 + 1;

       for (p1 = 0; p1 < k; p1++)
	if (rotamers[p1].m_index == index)
	  {
	    found = true;
	    break;
	  }
      
        if (found)
	{ 
	  k--;
	  continue;
	}
       
      int n1 = SIDECHAIN::m_aalist[chain.getLink(index)->getType()]->m_nRotamers;

      int ri;
      if (n1 > 1)
	{
	  ri = (lrand48() % (n1 - 1));
	  //if (ri >= chain.getLink(index)->getRotIndex())
	    //ri++;
	}
      else
	{
	  k--;
	  continue;
	}

      rotamers[k].m_index = index;     
      rotamers[k].m_rotIndex = ri;
    }

  // Insert stopper
  rotamers[k].m_index = length + 1;

  sort(rotamers.begin(), rotamers.end(), ROTAMER_CHANGE_COMP());  
}

void generateLigandMove(vector<LIGAND_CHANGE> & poses, int num_poses, int numconf)
{
  int k;
  // Generate ligand moves.

  //if (numconf < num_poses)
      //num_poses = numconf;

  //int used[num_poses];
  //int used[numconf];
  for (k = 0; k < num_poses; k++) //num_poses = 50 per torsion move
  //for (k = 0; k < numconf; k++)
  {
      bool found = false;

      int index = lrand48() % (numconf); //numconf = 100, number of ligand conformers
      /*
      for (int pp = 0; pp < k; pp++)
        {

          if (used[pp] == index)
            {
              cout << "index" << endl;
              found = true;
              break;
            }
        }
      if (found)
        {
          k--;
          continue;
        }
      */
      //used[k] = index;
      poses[k].m_confIndex = index;
    }

  // Insert stopper.
  poses[k].m_confIndex = numconf + 1;
  for (k = 0; k < num_poses; k++)
    cout << poses[k].m_confIndex;
  cout << "###########" << endl;

}

// Store the current state of the simulation.
void storeState(int step, REAL energy, ofstream & fout, CChain & chain)
{
  char cc[100];

  if (!noOutput)
    {
      int index = step/interval;
     
      sprintf(cc, "%s/%s_%06d.pdb", tempdir, ofile, index);
      chain.storeCoordinates(cc);
      sprintf(cc, "%s/%s_%06d.angs", tempdir, ofile, index);
      chain.storeAngsStyle(cc);
    }
  exit(0); 
  chain.getCaPositions(posCurr);
  REAL rot[3][3], trans[3];
  REAL rmsd = CRMSD(pos0, posCurr, rot, trans);
  
  fout << energy << " " << rmsd <<  endl;
}

